<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Lab 1 | Fast Robots</title>
  <link rel="stylesheet" href="../../style.css" />
  <style>
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 16px 0 10px;
    }

    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      text-decoration: none;
      border-radius: 10px;
      font-size: 14px;
    }

    .back-button:hover { text-decoration: none; filter: brightness(1.05); }

    .muted { color: var(--muted); }

    .media {
      background: rgba(255,255,255,0.04);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0 16px;
    }

    h2 {
      margin-top: 28px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .video-wrap {
      position: relative;
      width: 100%;
      padding-top: 56.25%;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #000;
      margin: 10px 0 16px;
    }

    .video-wrap iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    .footer {
      margin-top: 26px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }
    .img-small {
      max-width: 520px;
      width: 100%;
      height: auto;
      display: block;
      margin: 10px auto 6px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="topbar">
      <!-- Adjust this path based on where you put lab1.html -->
      <a class="back-button" href="../../index.html">← Back to Main Page</a>
      <span class="muted">Fast Robots | Spring 2026</span>
    </div>

    <h1>Lab 1: The Artemis board and Bluetooth</h1>
    <p class="subtitle">Artemis setup + BLE communication (Lab 1A and Lab 1B)</p>

    <!-- ===================== -->
    <!-- ====== LAB 1A ======= -->
    <!-- ===================== -->
    <h2 id="lab1a">Lab 1A</h2>

    <div class="card">
      <h3>Objective</h3>
      <p>
        The purpose of Lab 1A is to set up and become familiar with the Arduino IDE and the Artemis board.
      </p>
    </div>

    <div class="card">
      <h3>Setup</h3>
      <p>
        The Arduino IDE and SparkFun Apollo3 board package were installed and updated on my local machine.
        The SparkFun RedBoard Artemis Nano was selected as the active board and successfully connected via USB.
        I verified correct operation using example sketches and confirmed that all inputs operate at 3.3 V logic.
      </p>

    </div>

    <div class="card">
      <h3>Tasks</h3>

      <h4>Task 1: Blink</h4>
      <p>
        A basic blink sketch was uploaded to verify correct board configuration and GPIO operation.
      </p>
      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/vPq3t8IqA-8" allowfullscreen></iframe>
      </div>

      <h4>Task 2: Serial Communication</h4>
      <p>
        Serial communication was tested using the Arduino Serial Monitor and the board successfully
        transmitted formatted messages at the specified baud rate. 
      </p>
      <img src="Serial.png" alt="Serial Monitor output showing successful communication">

      <h4>Task 3: Temperature Sensor</h4>
      <p>
        The onboard temperature sensor was read using analog input. Measured values changed
        in response to touch and ambient conditions as shown in the video.
      </p>
      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/QgsjnWiClSM" allowfullscreen></iframe>
      </div>

      <h4>Task 4: Microphone</h4>
      <p>
        The microphone was used to detect sound intensity and dominant frequency components, 
        Changes in the output were observed when I change the frequency. 
      </p>
      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/bq4Tn3G5i3s" allowfullscreen></iframe>
      </div>

      <h4>Task 5: Electric Tuning</h4>
      <p>
        I combined microphone readout with serial output to create a simplified electronic tuner.
        The program detected and reported different dominant frequencies in real time.
      </p>
      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/vsboKM0xSfU" allowfullscreen></iframe>
      </div>

    </div>

    <div class="card">
      <h3>Conclusion</h3>
      <p>
        In this lab, I set up the Arduino IDE and learned how to use the Artemis Nano board.
        I tested basic functions such as blinking an LED, using the serial monitor, and reading
        data from the temperature sensor and microphone. This lab helped me understand the board
        and prepared me for later labs involving sensing and communication.
      </p>
    </div>




    <!-- ===================== -->
    <!-- ====== LAB 1B ======= -->
    <!-- ===================== -->
    <h2 id="lab1b">Lab 1B</h2>

    <div class="card">
      <h3>Objective</h3>
      <p>
        The purpose of Lab 1B is to establish communication between computer and the Artemis board through the Bluetooth stack. 
      </p>
    </div>

    <div class="card">
      <pre>
      <h3>Prelab</h3>

      <h4>Setup</h4>
      <p>
        The prelab prepared the laptop and RedBoard Artemis Nano for Bluetooth Low Energy (BLE) communication using the provided codebase. On the laptop, I set up a Python environment and installed the required BLE packages for the Jupyter notebooks.
      </p>
      
      <p>
        I then uploaded <code>ble_arduino.ino</code> to the Artemis, which initializes the ArduinoBLE library and configures the board to advertise a BLE service.
      </p>
      
      <p>
        After upload, the Artemis printed its BLE MAC address to the Serial Monitor (shown below), confirming that BLE was initialized and the board was discoverable.
      </p>

      <img class="img-small" src="mac.png" alt="Serial Monitor showing Artemis BLE MAC address">
     
      
      <div style="margin-top: 28px;"></div>
      
      <h4>Configuration</h4>
      <p>
        Before attempting a BLE connection, I configured the identifiers needed for the laptop to communicate with the correct Artemis board and BLE interface.
      </p>
      
      <p>
        I generated a unique BLE service UUID in Python using <code>uuid4()</code>. This service UUID was then copied into both the Arduino sketch and the Python configuration file. Using a unique service UUID prevents conflicts with other students’ BLE devices in the lab.
      </p>
      
      <img class="img-small" src="jp.png" alt="uuid4() used to generate a BLE service UUID">
    
      
      <p>
        The BLE service exposes three characteristics that define how data moves between the laptop and the Artemis:
      </p>
      
      <ul>
        <li><code>TX_CMD_STRING</code>: laptop → Artemis (write). Used to send command strings from Python.</li>
        <li><code>RX_STRING</code>: Artemis → laptop (notify/read). Used for string replies and streamed data.</li>
        <li><code>RX_FLOAT</code>: Artemis → laptop (notify/read). Used for numeric data.</li>
      </ul>
      
      <p>
        These characteristic UUIDs are defined in  Arduino sketch <code>ble_arduino.ino</code> so the Artemis advertises the expected BLE interface.
      </p>
      
      <img class="img-small" src="inosketch.png" alt="Arduino sketch showing BLE service and characteristic UUID definitions">
      
      
      <p>
        I then updated <code>connection.yaml</code> with the Artemis MAC address, service UUID, and characteristic UUIDs so the Python client could identify and connect to the correct BLE device.
      </p>
      
      <img class="img-small" src="yamlsk.png" alt="connection.yaml showing Artemis address, BLE service UUID, and characteristic UUIDs">
      
      
      <div style="margin-top: 28px;"></div>
      
      <h4>Code Base</h4>
      <p>
        The provided BLE codebase consists of two main components: an Arduino sketch running on the Artemis (acting as a BLE peripheral) and a Python notebook/client running on the laptop (acting as a BLE central).
      </p>
      
      <p>
        The Artemis advertises a BLE service and characteristics defined in <code>ble_arduino.ino</code>. The Python client reads the MAC address and UUID information from <code>connection.yaml</code>, initializes a BLE controller, and connects to the Artemis:
      </p>
      
      <pre><code class="language-python"># Get Artemis BLE controller
      ble = get_ble_controller()
      
      # Connect to the Artemis device
      ble.connect()</code></pre>
      
      <p>
        Once the connection succeeded, the Arduino Serial Monitor printed the central device address (picture below), confirming that the laptop successfully connected to the Artemis over BLE.
      </p>
      <img class="img-small" src="connected.png" alt="connected to address">     
      <p>
        After connecting, the laptop sends commands by writing to <code>TX_CMD_STRING</code>. The Artemis checks for incoming writes, parses the command, executes the corresponding handler, and returns results by writing to <code>RX_STRING</code>, which the laptop can read directly or receive asynchronously using BLE notifications.
      </p></pre>
      
      
    







    <div class="card">
      <h3>Tasks</h3>

      <h4>Task 1: ECHO Command</h4>
      <p>
        The goal of this task is to send a string from the laptop to the Artemis using the <code>ECHO</code> command, then read back an
        “augmented” reply from the Artemis over the BLE string characteristic.
      </p>
      <p>
        First, I sent a test payload From Python using:
      </p>
      <pre><code class="language-python">ble.send_command(CMD.ECHO, "HiHello")</code></pre>

      <p>
        On the Artemis side, the command is received through the writeable command characteristic, parsed by
        <code>RobotCommand</code>, and the string is extracted into <code>char_arr</code>. I then built
        the response using <code>EString</code> and wrote it back to the BLE TX string characteristic.
      </p>

      <h5>Relevant Code Snippet (Arduino)</h5>
      <pre><code class="language-cpp">case ECHO:
        char char_arr[MAX_MSG_SIZE];
        success = robot_cmd.get_next_value(char_arr);
        if (!success) return;

        tx_estring_value.clear();
        tx_estring_value.append("Robot says -> ");
        tx_estring_value.append(char_arr);
        tx_estring_value.append(" :)");
        tx_characteristic_string.writeValue(tx_estring_value.c_str());

        Serial.print("Echo reply: ");
        Serial.println(tx_estring_value.c_str());
        break;</code></pre>

      <p>
        After sending <code>HiHello</code> from Python, the laptop received the modified reply
        <code>Robot says -> HiHello :)</code>. The Serial Monitor also confirmed the command reception and the
        generated reply.
      </p>

      <img class="img-small" src="echo.png" alt="Serial monitor showing RX wrote and Echo reply for the ECHO command">



     
    

      <h4>Task 2: Send Three Floats</h4>

      <p>
      The goal of this task was to confirm that the BLE command channel can reliably transmit
      numeric values (floats) from the laptop to the Artemis, and that the Artemis can parse the
      payload into individual numbers.
      </p>
      
      <p>
      First, I sent three floats using the <code>SEND_THREE_FLOATS</code> command.
      The three values were packed into a single string and separated by the <code>|</code> delimiter
      so the provided <code>RobotCommand</code> parser could tokenize them in order.
      </p>
      
      <pre><code class="language-python">ble.send_command(CMD.SEND_THREE_FLOATS, "1.1|2.2|3.3")</code></pre>
      
      <p>
      On the Artemis side, the handler calls <code>get_next_value()</code> three times to extract the
      floats sequentially and then prints them to the Serial Monitor to verify correct decoding.
      </p>
      
      <h5>Relevant Code Snippet (Arduino)</h5>
      <pre><code class="language-cpp">case SEND_THREE_FLOATS:
        float f1, f2, f3;
      
        success = robot_cmd.get_next_value(f1); if (!success) return;
        success = robot_cmd.get_next_value(f2); if (!success) return;
        success = robot_cmd.get_next_value(f3); if (!success) return;
      
        Serial.print("Three floats received: ");
        Serial.print(f1); Serial.print(", ");
        Serial.print(f2); Serial.print(", ");
        Serial.println(f3);
        break;</code></pre>
      
      <p>
      After running the command, the Serial Monitor showed both the received command payload and
      the parsed float values, confirming that the message was delivered over BLE and decoded correctly.
      </p>
      
      <img class="img-small" src="float.png" alt="Serial output showing RX wrote and three floats received">





      <h4>Task 3: GET_TIME_MILLIS</h4>
      

        <p>
        The goal of this task was to make the Artemis return its current timestamp
        back to the laptop as a formatted string. 
        </p>

        <p>
        From Python, I triggered the <code>GET_TIME_MILLIS</code> command, then immediately read back the response
        string from the Artemis using the BLE string characteristic. The expected format is <code>T:&lt;millis&gt;</code>.
        </p>

        <pre><code class="language-python">ble.send_command(CMD.GET_TIME_MILLIS, "")
        s = ble.receive_string(ble.uuid['RX_STRING'])
        print("Python received:", s)</code></pre>

        <p>
        On the Artemis side, the command handler calls <code>millis()</code> to get the current time (ms),
        builds a string with the prefix <code>T:</code>, then writes it to the BLE TX string characteristic
        so the laptop can read it.
        </p>

        <h5>Relevant Code Snippet (Arduino)</h5>
        <pre><code class="language-cpp">case GET_TIME_MILLIS: {
        unsigned long t = millis();

        tx_estring_value.clear();
        tx_estring_value.append("T:");
        tx_estring_value.append((int)t);

        tx_characteristic_string.writeValue(tx_estring_value.c_str());

        Serial.print("Sent time: ");
        Serial.println(t);
        break;
        }</code></pre>

        <p>
        After sending the command, the laptop received a timestamp string in the expected format.
        The Arduino Serial Monitor also printed the same timestamp, confirming the value sent over BLE.
        </p>

        <div class="media">
        <strong>Observed output:</strong>
        <img class="img-small" src="31.png" alt="31">
        <img class="img-small" src="32.png" alt="32">
        
        </div>




      <h4>Task 4: Notification Handler</h4>

        <p>
        In this task, I implemented a BLE notification handler in Python to receive string data
        from the Artemis asynchronously, without explicitly requesting each message.
        </p>

        <p>
        On the Python side, I subscribed to the <code>RX_STRING</code> BLE characteristic.
        Whenever the Artemis writes a new string value, the notification handler is automatically
        invoked.
        </p>

        <h5>Python Notification Handler</h5>
        <pre><code class="language-python">times_ms = []

        def notif_handler(uuid, byte_array):
            msg = ble.bytearray_to_string(byte_array).strip()
            if msg.startswith("T:"):
                times_ms.append(int(msg[2:]))

        ble.start_notify(ble.uuid['RX_STRING'], notif_handler)</code></pre>

        <p>
        The handler converts the incoming BLE bytes into a string, checks for the
        <code>T:&lt;millis&gt;</code> format, and extracts the timestamp value.
        These timestamps are stored for later analysis.
        </p>



      <h4>Task 5: Time Streaming and Data Rate</h4>

        <p>
        In this task, I measured how fast the Artemis can stream data to the laptop using
        Bluetooth Low Energy notifications. The Artemis continuously sent timestamp
        values for a fixed duration, while the laptop collected and analyzed the data
        asynchronously using the notification handler from Task 4.
        </p>

        <p>
        From Python, I triggered the streaming behavior and collected the received
        timestamps for several seconds:
        </p>

        <h5>Python Code Snippet</h5>
        <pre><code class="language-python">
        import asyncio
        times_ms.clear()
        ble.send_command(CMD.GET_TIME_RATE, "")
        await asyncio.sleep(6.0)

        print("Messages received:", len(times_ms))
        print("First 5:", times_ms[:5])
        print("Last 5:", times_ms[-5:])
        </code></pre>

        <p>
        On the Artemis side, the <code>GET_TIME_RATE</code> command sends the current time
        (in milliseconds) at a fixed interval using BLE notifications. The loop runs for
        approximately 5 seconds and throttles transmissions to avoid overwhelming the
        BLE stack.
        </p>

        <h5>Arduino Code Snippet</h5>
        <pre><code class="language-cpp">
        case GET_TIME_RATE:
        {
        unsigned long start_ms = millis();
        unsigned long next_send_ms = start_ms;
        const unsigned long SEND_PERIOD_MS = 20; 

        while (millis() - start_ms < 5000) {
            BLE.poll();
            unsigned long now = millis();
            if (now >= next_send_ms) {
            tx_estring_value.clear();
            tx_estring_value.append("T:");
            tx_estring_value.append((int)now);
            tx_characteristic_string.writeValue(
                tx_estring_value.c_str()
            );
            next_send_ms = now + SEND_PERIOD_MS;
            }
        }
        break;
        }
        </code></pre>

        <p>
        During one run, the Python client received <strong>207 timestamp messages</strong>.
        The first and last timestamps were:
        </p>

        <ul>
        <li>First timestamp: <code>50465 ms</code></li>
        <li>Last timestamp: <code>55456 ms</code></li>
        </ul>
        <img class="img-small" src="5.png" alt="input">

        <p>
        This corresponds to a total streaming duration of:
        </p>

        <p>
        55456 − 50465 = 4991 ms ≈ 4.99 s
       </p>

        <p>
        The effective message rate was:
        </p>

        <p>
        207 messages / 4.99 s ≈ 41.5 messages per second
        </p>

        <p>
        Each message had the format <code>"T:xxxxx"</code>, which is approximately
        7 bytes per message. The effective BLE payload throughput was therefore:
        </p>

        <p>
        41.5 messages/s × 7 bytes ≈ 290 bytes/s ≈ 0.28 KiB/s
        </p>



        <h4>Task 6: Time Storage</h4>
    
        <p>
        The objective of this task was to store time stamp data locally on the Artemis using a global buffer, then transmit the buffered data to the laptop in a single batch. This approach avoids continuous streaming and allows verification that all recorded data points were successfully transferred over BLE.
        </p>

        <p>
        On the Artemis side, I created a global array to store time stamps along with a counter to track how many values were recorded. When the <code>RECORD_TIME_DATA</code> command is received, the Artemis records <code>millis()</code> values for a fixed duration or until the buffer is full. These values are stored locally without being sent immediately.
        </p>

        <p>
        After recording is complete, the <code>SEND_TIME_DATA</code> command iterates through the buffer and sends each stored time stamp to the laptop as a string prefixed with <code>T:</code>. Once all values are transmitted, the Artemis sends a <code>DONE</code> message to signal completion.
        </p>

        <pre><code class="language-cpp">
        case RECORD_TIME_DATA:
        {
            time_count = 0;
            unsigned long start_ms = millis();

            while ((millis() - start_ms < 5000) && (time_count < TIME_BUF_LEN)) {
                BLE.poll();
                time_buf[time_count++] = millis();
            }

            Serial.print("Recorded count = ");
            Serial.println(time_count);
            break;
        }

        case SEND_TIME_DATA:
        {
            Serial.print("Sending count = ");
            Serial.println(time_count);

            for (int i = 0; i < time_count; i++) {
                BLE.poll();
                tx_estring_value.clear();
                tx_estring_value.append("T:");
                tx_estring_value.append((int)time_buf[i]);
                tx_characteristic_string.writeValue(tx_estring_value.c_str());
                delay(5);
            }

            tx_estring_value.clear();
            tx_estring_value.append("DONE");
            tx_characteristic_string.writeValue(tx_estring_value.c_str());

            Serial.println("Sent DONE");
            break;
        }
        </code></pre>

        <h4>Buffered Notification Handler (Python)</h4>
        <p>
        On the Python side, I used a buffered BLE notification handler to receive the burst of messages asynchronously. Incoming time values were appended to a list, and a completion event was triggered once the <code>DONE</code> message was received.
        </p>

        <pre><code class="language-text">
        on notification received:
            convert BLE bytes to string
            if message starts with "T:":
                parse time and append to list
            if message == "DONE":
                mark transfer complete
        </code></pre>

        <p>
        After issuing the <code>RECORD_TIME_DATA</code> command and allowing the buffer to fill, I sent the <code>SEND_TIME_DATA</code> command from Python. The laptop successfully received all buffered time values followed by the <code>DONE</code> message.
        </p>

        <img class="img-small" src="61.png"
            alt="Python output confirming buffered data received">


        <img class="img-small" src="62.png"
            alt="Arduino Serial Monitor showing buffered recording and send">



        <h4>Task 7: Buffered Time + Temperature Pairs</h4>

        <p>
        The objective of this task was to record <strong>paired</strong> time stamps and temperature readings on the Artemis using two same-length global arrays. Each index in the arrays corresponds to one sample (i.e., <code>time_buf[i]</code> was recorded at the same moment as <code>temp_buf[i]</code>). After recording, the Artemis sends the paired data back to the laptop, and the Python notification handler parses each packet into two lists.
        </p>

        <p>
        I added a second global buffer (<code>temp_buf</code>) with the same length as the time buffer. The command <code>RECORD_TEMP_DATA</code> records both <code>millis()</code> and <code>read_temp_c()</code> at approximately 50 Hz for 5 seconds (or until the buffer is full). 
        </p>

        <pre><code class="language-cpp">
        case RECORD_TEMP_DATA: {
            Serial.println("Entered RECORD_TEMP_DATA");

            time_count = 0;
            unsigned long start_ms = millis();

            while (((millis() - start_ms) < 5000) && (time_count < TIME_BUF_LEN)) {
                BLE.poll();
                time_buf[time_count] = millis();
                temp_buf[time_count] = read_temp_c();
                time_count++;
                delay(20);  // ~50 Hz
            }

            Serial.print("Recorded paired samples = ");
            Serial.println(time_count);
            break;
        }
        </code></pre>
        <p>
        The command <code>GET_TEMP_READINGS</code> then iterates through both arrays and sends each paired sample as a single formatted string:
        <code>D:&lt;time_ms&gt;,&lt;temp_x100&gt;</code>. After all samples are sent, the Artemis transmits a <code>DONE</code> message.
        </p>

        <pre><code class="language-cpp">
        case GET_TEMP_READINGS: {
            Serial.println("Entered GET_TEMP_READINGS");
            Serial.print("Sending paired samples = ");
            Serial.println(time_count);

            char out[64];

            for (int i = 0; i < time_count; i++) {
                BLE.poll();
                long temp_c_x100 = (long)(temp_buf[i] * 100.0f);
                snprintf(out, sizeof(out), "D:%lu,%ld", time_buf[i], temp_c_x100);
                tx_characteristic_string.writeValue(out);
                delay(5);
            }

            tx_characteristic_string.writeValue("DONE");
            delay(20);
            tx_characteristic_string.writeValue("DONE");
            delay(20);
            tx_characteristic_string.writeValue("DONE");
            break;
        }
        </code></pre>

        <h4>Buffered Notification Handler (Python)</h4>
        <p>
        On the Python side, I registered a notification handler that listens for incoming strings. Each data packet begins with <code>D:</code> and contains a comma-separated time stamp and temperature value scaled by 100. The handler parses these messages and appends values into two lists (<code>t_list</code> and <code>temp_list</code>). Once a <code>DONE</code> message is received, the transfer is treated as complete.
        </p>

        <pre><code class="language-text">
        on notification received:
            convert BLE bytes to string
            if message starts with "D:":
                parse time_ms and temp_x100
                t_list.append(time_ms)
                temp_list.append(temp_x100 / 100)
            if message == "DONE":
                mark transfer complete
        </code></pre>

        <p>
        After recording data for ~5 seconds and requesting the paired readings, the laptop received the same number of time stamps and temperature values, confirming that the data remained aligned by index.
        </p>


        <img class="img-small" src="71.png"
            alt="Python output confirming buffered data received">

        <img class="img-small" src="72.png"
            alt="Python output confirming buffered data received">


    
            <h4>Task 8: Real-Time Streaming vs Buffered Data Transfer</h4>

            <p>
            In this lab, I explored two different ways of sending data from the Artemis to my laptop:
            sending data in real time as it is generated, and storing data locally on the Artemis before
            sending it all at once. Each approach has different advantages depending on the situation.
            </p>
            
            <h5>Real-Time Streaming</h5>
            <p>
            With real-time streaming, the Artemis sends each data point over BLE immediately after it is
            recorded. This makes it possible to observe the system state live from the laptop, which can
            be useful for debugging, visualization, or applications that require immediate feedback.
            </p>
            
            <p>
            The main drawback is that BLE communication is relatively slow. From Task 5, I measured an
            effective rate of about <strong>41.5 messages per second</strong>, corresponding to roughly
            <strong>0.28 KiB/s</strong> of data throughput. Because each data point is sent individually, the BLE
            overhead limits how fast data can be streamed and reduces the achievable sampling rate.
            </p>
            
    
            <h5>Buffered Data Collection and Transfer</h5>
            <p>
            In the buffered approach, data is first stored in arrays on the Artemis and only transmitted
            after data collection is complete. This separates data recording from BLE communication.
            </p>
            
            <p>
            This method allows the Artemis to record data much faster than it can send it over BLE.
            In Tasks 6 and 7, the board recorded timestamped data at approximately <strong>50 Hz</strong>, which
            was limited by loop timing and sensor delays rather than BLE throughput. Once recording
            finished, the stored data was sent efficiently in a batch.
            </p>
            
            <p>
            The main disadvantage of this approach is that the data is not available in real time and
            that the amount of data that can be recorded is limited by the board’s memory. However, it
            is well suited for data logging and offline analysis where higher resolution is required.
            </p>
            
            <h5>Recording Speed Comparison</h5>
            <p>
            Comparing the two methods, buffered recording is significantly faster than real-time
            streaming. While BLE streaming achieved about <strong>41.5 messages per second</strong>, buffered
            recording captured data at approximately <strong>50 samples per second</strong> without being
            constrained by BLE communication. This shows that separating data acquisition from data
            transfer allows for higher sampling rates.
            </p>
            
            <h5>Memory Limitations</h5>
            <p>
            The Artemis board has <strong>384 kB (393,216 bytes)</strong> of RAM. In Task 7, each stored data point
            consisted of a timestamp and a temperature reading:
            </p>
            
            <ul>
              <li>Timestamp (<code>unsigned long</code>): 4 bytes</li>
              <li>Temperature (<code>float</code>): 4 bytes</li>
            </ul>
            
            <p>
            This results in <strong>8 bytes per data point</strong>. Ignoring memory used by the program and stack,
            the theoretical maximum number of stored data points is:
            </p>
            
            <p>
            <code>393,216 bytes / 8 bytes ≈ 49,000 data points</code>
            </p>
            
            <p>
            In practice, fewer samples can be stored due to memory used by the BLE stack and other
            variables, but this still allows tens of thousands of samples to be recorded before
            transmission.
            </p>
            
            <p>
            Overall, I think real-time streaming is more useful for live monitoring and feedback, while buffered
            data transfer is better for collecting high-resolution data for later analysis.
            </p>


        
        <h4>Task 9: Effective Data Rate and BLE Overhead</h4>

        
        <p>
            I measured round-trip time and effective payload throughput for two reply sizes: a small
            5-byte message and a larger 120-byte message. Each command was sent repeatedly from Python,
            and the response time was measured using BLE notifications.
        </p>

        <h4>Arduino Implementation</h4>
        <code class="language-cpp">
        case REPLY_5B:
        tx_characteristic_string.writeValue("ABCDE");
        break;

        case REPLY_120B:
        static char msg[121];
        memset(msg, 'A', 120);
        msg[120] = '\0';
        tx_characteristic_string.writeValue(msg);
        break;</code>

        <h4>Python Measurement (condensed)</h4>
        <pre><code class="language-python"># handler timestamps replies
        def on_rx(uuid, b):
            rx_q.put_nowait((time.perf_counter_ns(),
                            len(ble.bytearray_to_string(b))))

        ble.start_notify(ble.uuid["RX_STRING"], on_rx)

        async def bench(cmd, nbytes, N=200):
            rtt, rate = [], []
            for _ in range(N):
                while not rx_q.empty(): rx_q.get_nowait()
                t0 = time.perf_counter_ns()
                ble.send_command(cmd, "")
                t1, _ = await rx_q.get()
                dt = (t1 - t0)/1e6
                rtt.append(dt)
                rate.append((nbytes/(dt/1000))/1024)
            return np.mean(rtt), np.mean(rate)

        rtt5, rate5   = await bench(CMD.REPLY_5B, 5)
        rtt120, rate120 = await bench(CMD.REPLY_120B, 120)</code></pre>

        <h4>Results</h4>
        <ul>
            <li><strong>5-byte reply:</strong> RTT ≈ 89.0 ms, rate ≈ 0.056 KiB/s</li>
            <li><strong>120-byte reply:</strong> RTT ≈ 92.9 ms, rate ≈ 1.29 KiB/s</li>
        </ul>

        <img class="img-small" src="91.png" alt="BLE throughput vs payload size">
        <img class="img-small" src="92.png" alt="f">

        <p>
            From the result, we can see that RTT was nearly the same for both payload sizes, indicating that BLE communication is dominated
            by fixed overhead rather than payload length. Small packets suffer heavily from this overhead,
            resulting in very low effective throughput. Larger replies significantly reduce overhead per byte
            and achieve much higher data rates.
        </p>
        </section>

       
        <h4>Task 10: Reliability at High Data Rates</h4>

        <p>
            When the Artemis sends data at a higher rate, the computer does not reliably receive every
            message. As the transmission rate increases, BLE notifications begin to drop packets instead
            of buffering them.
        </p>

        <p>
            This behavior was observed during real-time streaming (Task 5), where fewer samples were
            received than expected over a fixed time window. In contrast, when data was first stored on
            the Artemis and then sent afterward (Tasks 6 and 7), all samples were consistently received,
            as confirmed by matching counts and DONE markers.
        </p>

        <p>
            BLE notifications are not guaranteed-delivery messages. If the Artemis publishes data faster
            than the Python client can process it, older messages are lost.
        </p>

        <p>
            In summary, real-time streaming over BLE becomes unreliable at high data rates, while buffered
            data transfer is much more robust and should be used when complete data collection is required.
        </p>
        </section>









      





    <div class="card">
      <h3>Conclusion</h3>
      <p>
        <!-- What you learned, biggest debugging issue, how you solved it -->
      </p>
    </div>

    <div class="footer">
      <a class="back-button" href="../../index.html">← Back to Main Page</a>
      <span>Last updated: <!-- optional date --></span>
    </div>
  </div>
</body>
</html>