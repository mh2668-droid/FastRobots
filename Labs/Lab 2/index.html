<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Lab 1 | Fast Robots</title>
  <link rel="stylesheet" href="../../style.css" />
  <!-- MathJax for LaTeX equations -->
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 16px 0 10px;
    }

    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      text-decoration: none;
      border-radius: 10px;
      font-size: 14px;
    }

    .back-button:hover { text-decoration: none; filter: brightness(1.05); }

    .muted { color: var(--muted); }

    .media {
      background: rgba(255,255,255,0.04);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0 16px;
    }

    h2 {
      margin-top: 28px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .video-wrap {
      position: relative;
      width: 100%;
      padding-top: 56.25%;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #000;
      margin: 10px 0 16px;
    }

    .video-wrap iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    .footer {
      margin-top: 26px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }
    .img-small {
      max-width: 520px;
      width: 100%;
      height: auto;
      display: block;
      margin: 10px auto 6px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .img-medium {
      max-width: 800px;
      width: 100%;
      height: auto;
      display: block;
      margin: 10px auto 6px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="topbar">
      <!-- Adjust this path based on where you put lab1.html -->
      <a class="back-button" href="../../index.html">← Back to Main Page</a>
      <span class="muted">Fast Robots | Spring 2026</span>
    </div>

    <h1>Lab 2: IMU</h1>
   



    <div class="card">
      <h3>Objective</h3>
      <p>
        The goal of this lab was to acquire and analyze accelerometer and gyroscope data from a 9-DOF IMU on the Artemis board. Pitch, roll, and yaw were computed using sensor models from class, and low-pass and complementary filters were applied to improve robustness. IMU data was buffered onboard and transmitted over Bluetooth for offline analysis in Python.
      </p>
    </div>

    <div class="card">
      <h3>Setup</h3>
      <p>
        I first installed the ICM-20948 Arduino Library using the Arduino Library Manager. 
        The IMU was connected to the RedBoard Artemis Nano using the QWIIC connectors.
      </p>
      <img class="img-small" src="connection.png" alt="connection imu">
      <p>
        To verify the hardware connection and library setup, I ran the example sketch
from the SparkFun library. After uploading, the Serial Monitor can successfully print accelerometer, gyroscope, and magnetometer data.
      </p>


      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/1i1zINzfdO0" allowfullscreen></iframe>
      </div>

      <h4>AD0_VAL Discussion</h4>
        <p>
            In the example code, the variable AD0_VAL specifies the least significant bit of the IMU’s I²C address.
            This value depends on the hardware configuration of the board. On the SparkFun breakout, the AD0 pin is pulled high by default, so AD0_VAL should be set to 1.

            
        </p>
      
      <h4>Accelerometer and Gyroscope Behavior</h4>
      <p>
        While I ran the example code, the accelerometer readings changed with board orientation. When the board was stationary and lying flat, one axis measured approximately ±1 g due to gravity while the other axes remained near zero, and tilting or flipping the board redistributed this gravity component across axes.
        And the gyroscope measured angular velocity, which means staying near zero when the board was still and producing clear spikes during rotation, with faster motion would cause a larger values before returning close to zero. 
      </p>




    </div>




    <div class="card">
      <h3>Tasks</h3>

      <div>

      <h4>1. Accelerometer</h4>
      <p>
        The goal of this section was to use accelerometer measurements to estimate board orientation and to understand the effects of noise on these measurements. 
        First, Pitch and roll were computed using the standard equations discussed in class, based on the gravity vector measured by the accelerometer.
        These equations estimate orientation by comparing the acceleration components along each axis:
      </p>

      <p>
        $$
         \theta_a = \operatorname{atan2}(a_x, a_z) 
        $$
      </p>
      
      <p>
        $$
         \phi_a = \operatorname{atan2}(a_y, a_z) 
        $$
      </p>

      <p>   
        In Arduino IDE, the accelerometer values were read in milligravity units and converted into pitch and roll angles as follows:
      </p>
      <pre><code class="language-cpp">float roll_rad  = atan2(ay, az);
float pitch_rad = atan2(-ax, sqrt(ay*ay + az*az));
float roll_deg  = roll_rad  * 180.0 / M_PI;
float pitch_deg = pitch_rad * 180.0 / M_PI;
</code></pre>

      <p>
        To validate the accelerometer-based orientation estimates, I rotated the IMU through known angles and recorded the output.
        Figures below show the roll and pitch angles as the board was positioned near −90°, 0°, and +90°.
      </p>
      <img class="img-medium" src="pandr.png" alt="pitch and roll">
      <p>  
        When the board was held flat, both pitch and roll remained near 0°. Rotating the board by approximately ±90° caused the corresponding angle to saturate near ±90°, 
        as expected from the geometry of the gravity vector. Small fluctuations near the extrema were due to sensor noise and slight hand motion during the test.
      </p>

    
      <p>
        A short video was also recorded showing the physical motion of the board alongside the serial output to confirm that the reported angles tracked the motion in real time.
      </p>

      <div class="video-wrap">
        <iframe src="https://www.youtube.com/embed/nd0B1BVTZLU" allowfullscreen></iframe>
      </div>
      <p>

        From the collected accelerometer data and the pitch and roll plots, I evaluated the accuracy of the angle estimates at approximately −90°, 0°, and +90°. For each orientation, 
        the measured angles closely matched the expected values, with the readings typically fluctuating within about 1–2 degrees. Across all tested orientations, the accelerometer provided reliable pitch and roll estimates under static conditions. A two-point calibration was not necessary for this part of the lab.
      </p>

      <p>
        
        To analyze noise in the accelerometer data, I examined the z-axis acceleration (az) recorded while manually rotating and holding the IMU. 
      </p>
      <img class="img-small" src="az.png" alt="az">

      <p>
        The figure above shows the time-domain az signal. While the gravity component dominates when the IMU is held steady, the signal contains sharp transients and noticeable high-frequency jitter during orientation changes. These effects are especially visible around the transition regions, where spikes and oscillations appear before the signal settles.
        Small fluctuations remain even after the IMU becomes stationary. This behavior motivates further analysis in the frequency domain.
      </p>

      <p>   
        To understand the frequency content of the noise, I computed the Fast Fourier Transform (FFT) of the entire az signal using Python. The FFT converts the time-domain signal into the frequency domain, allowing individual frequency components to be examined.

      </p>

      <p>   
        The discrete Fourier transform is defined as:
      </p>

      <p>
      $$
      X(f_k) = \sum_{n=0}^{N-1} x[n] e^{-j 2 \pi k n / N}
      $$
      </p>

      <p>
        where x[n] is the sampled signal and N is the total number of samples.
      </p>

      <img class="img-small" src="fft.png" alt="eq2">

      <p>
        The figure above shows the FFT amplitude spectrum of az. Most of the signal energy is concentrated below approximately 1–2 Hz, showing that slow orientation changes and the gravity component. Above this range, the spectrum flattens and contains lower-amplitude components associated with noise and vibration.
        So, a cutoff frequency of approximately 2 Hz was chosen. 
      </p>

      <p>

        Using the cutoff frequency from the FFT, I applied a first-order RC low-pass filter to the accelerometer-based pitch and roll computed from the accelerometer equations. The RC relationship from lecture is:
      </p>

      <p>
        $$
        RC = \frac{1}{2\pi f_c}
        $$
      </p>
      
      <p>
        and the discrete-time low-pass filter update is:
      </p>
      
      <p>
        $$
        \alpha = \frac{\Delta t}{RC + \Delta t},
        \qquad
        y[k] = \alpha x[k] + (1-\alpha)\,y[k-1]
        $$
      </p>
      <p>
        This is implemented directly in my Arduino code as:
      </p>

      <pre><code class="language-cpp">float tau = 1.0 / (2 * M_PI * fc);
float alpha = dt / (tau + dt);
az_filt = alpha * az + (1 - alpha) * az_filt;
</code></pre>

      <img class="img-small" src="og vs lpf.png" alt="eq2">

      <p>
        The figure above compares the original az signal to the low-pass filtered output. The filtered signal is significantly smoother and effectively suppresses high-frequency jitter and sharp spikes present in the raw data, while preserving the overall trend of the motion.
        The low pass filter removes high frequency noise but causes a small delay when the motion changes quickly. 
        The FFT shows that most of the noise is at higher frequencies, which helps explain why this cutoff frequency works well. 
        Overall, The filtered signal is smoother and more stable, making it better for later use such as sensor fusion. 
      </p>
    </div>

    <div>

        <h4>2. Gyroscope</h4>

        <p>
        The goal of this section is to compute orientation angles using the gyroscope, compare them with accelerometer-based estimates, and show how a complementary filter improves accuracy and stability.
        </p>
        <p>
            To estimate orientation from the gyroscope, I integrated the gyro angular rates over time using the discrete-time update from lecture:
        </p>
        <p>
        $$
        \theta[k] = \theta[k-1] + \omega[k]\Delta t
        $$
        </p>
        <p>
            Because the gyroscope measures angular velocity, small biases accumulate over time, leading to drift in the estimated angles.
            The gyroscope-based pitch was compared with raw accelerometer pitch and low-pass filtered accelerometer pitch at both 30 Hz and 10 Hz.
        </p>
        <img class="img-small" src="pitch10.png" alt="eq2">
        <img class="img-small" src="pitch30.png" alt="eq2">
        <p>
            In the pitch plots, the raw accelerometer estimate is noisy and contains spikes during motion, while the filtered accelerometer estimate is smoother but slightly lags during rapid transitions. The gyroscope pitch is smooth and responds quickly, but it gradually drifts away from the accelerometer-based estimates, particularly after motion ends.
        </p>
        <p>

            <img class="img-small" src="roll10.png" alt="eq2">
            <img class="img-small" src="roll30.png" alt="eq2">
        </p>
        <p>
            A similar trend is observed in the roll plots. The raw accelerometer roll shows large spikes and instability, the filtered accelerometer roll significantly reduces this noise, and the gyroscope roll remains smooth but exhibits offset and drift over time.
            Comparing sampling frequencies, the 30 Hz results track motion more accurately and return closer to the original baseline after movement. At 10 Hz, both pitch and roll show increased drift and reduced accuracy, indicating that lower sampling frequency amplifies integration error and degrades gyroscope based angle estimation.

        </p>

























    





     










        </div>









      





    <div class="card">
      <h3>Conclusion</h3>
      <p>
        <p>
        
        
                In this lab, I learned how Bluetooth Low Energy communication works between the Artemis
                board and my laptop, including command-based messaging, notifications, and buffered
                data transfer. I also saw how BLE overhead limits real-time streaming rates and why
                storing data locally before transmission enables higher sampling rates and more
                reliable data collection.
                </p>
                
                <p>
                The main challenges involved debugging notification handlers and preventing data loss
                when sending data at higher rates. These issues were resolved by buffering data on the
                Artemis and using asynchronous handling in Python. Over the course of the lab, I also
                sharpened my index-based HTML formatting skills while organizing results and
                creatin the write-up.
                </p>
      
    </div>

    <div class="footer">
      <a class="back-button" href="../../index.html">← Back to Main Page</a>
      <span>Last updated: <!-- optional date --></span>
    </div>
  </div>
</body>
</html>